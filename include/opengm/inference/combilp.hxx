//
// File: combilp.hxx
//
// This file is part of OpenGM.
//
// Copyright (C) 2013 Bodgan Savchynskyy
// Copyright (C) 2016-2017 Stefan Haller
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//

#ifndef OPENGM_COMBILP_HXX
#define OPENGM_COMBILP_HXX

// To enable detailed debug output enable the following preprocessor macro:
// #define OPENGM_COMBILP_DEBUG
//
// FIXME: The above macro should be a parameter, maybe?

#include <iostream>
#include <vector>

#include <boost/scoped_ptr.hpp>

// NOTE: Remove this when debug code is removed.
#include <opengm/utilities/canonical_view.hxx>

#include <opengm/graphicalmodel/graphicalmodel_manipulator.hxx>
#include <opengm/inference/auxiliary/lp_reparametrization.hxx>

#include <opengm/inference/combilp/reparametrization.hxx>
#include <opengm/inference/combilp/utils.hxx>

namespace opengm{

template<class GM>
struct CombiLP_ILP_GraphicalModelTypeGen
{
	typedef typename GraphicalModelManipulator<
		typename LPReparametrizer<GM>::ReparametrizedGMType
	>::MGM
	GraphicalModelType;
};

////////////////////////////////////////////////////////////////////////////////
//
// class CombiLP
//
////////////////////////////////////////////////////////////////////////////////

//
// The LP solver template argument should be an inference algorithm working on
// the original GrahpicalModel GM.
//
// The ILP solver template argument should be an inference algorithm working on
// an auxiliary GraphicalModel. The auxiliary type can be generated by using
// the type generator CombiLP_ILP_GraphicalModelTypeGen<LPSOLVER>::GraphicalModelType.
//
// An easier interface is provided in the combilp_default.hxx header file! For
// example you could simply use
//
// #include <opengm/inference/combilp_default.hxx>
// CombiLP_TypeGen<CombiLP_LP_TRWS_Shekhovtsov, CombiLP_ILP_Cplex>::CombiLP combilp;
//

/// \brief CombiLP\n\n
/// Savchynskyy, B. and Kappes, J. H. and Swoboda, P. and Schnoerr, C.:
/// "Global MAP-Optimality by Shrinking the Combinatorial Search Area with Convex Relaxation".
/// In NIPS, 2013.
/// \ingroup inference
template<class GM, class ACC, class LP, class ILP>
class CombiLP : public Inference<GM, ACC>
{
public:
	//
	// Types
	//
	typedef ACC AccumulationType;
	typedef GM GraphicalModelType;
	typedef LP LPSolverType;
	typedef ILP ILPSolverType;
	OPENGM_GM_TYPE_TYPEDEFS;
	typedef std::vector<LabelType> Labeling;

	typedef visitors::VerboseVisitor< CombiLP<GM, ACC, LP, ILP> > VerboseVisitorType;
	typedef visitors::EmptyVisitor< CombiLP<GM, ACC, LP, ILP> > EmptyVisitorType;
	typedef visitors::TimingVisitor< CombiLP<GM, ACC, LP, ILP> > TimingVisitorType;

	typedef LPReparametrizer<GraphicalModelType> ReparametrizerType;
	typedef typename ReparametrizerType::ReparametrizedGMType ReparametrizedGMType;
	typedef GraphicalModelManipulator<ReparametrizedGMType> ManipulatorType;
	typedef std::vector<bool> MaskType;

	// Note: RebindGm and RebindGmAndAcc interfaces can not be implemented
	// here, as the LP and ILP template arguments will definitely also
	// rely on these types.

	struct Parameter
	{
		typedef typename LPSolverType::Parameter LPParameterType;
		typedef typename ILPSolverType::Parameter ILPParameterType;

		Parameter
		(
			LPParameterType lpsolverParameter = LPParameterType(),
			ILPParameterType ilpsolverParameter = ILPParameterType(),
			size_t maxNumberOfILPCycles = 100,
			bool verbose = false,
			std::string loadReparametrizationFileName = "",
			std::string saveReparametrizationFileName = "",
			bool enableDenseVersion = false,
			bool enablePotentialRedistribution = false,
			bool saveProblemMasks = false,
			std::string maskFileNamePre = "",
			size_t threads = 1
		)
		: lpsolverParameter_(lpsolverParameter)
		, ilpsolverParameter_(ilpsolverParameter)
		, maxNumberOfILPCycles_(maxNumberOfILPCycles)
		, verbose_(verbose)
		, loadReparametrizationFileName_(loadReparametrizationFileName)
		, saveReparametrizationFileName_(saveReparametrizationFileName)
		, enableDenseVersion_(enableDenseVersion)
		, enablePotentialRedistribution_(enablePotentialRedistribution)
		, saveProblemMasks_(saveProblemMasks)
		, maskFileNamePre_(maskFileNamePre)
		, threads_(threads)
		{
		}

		size_t maxNumberOfILPCycles_;
		bool verbose_;
		std::string loadReparametrizationFileName_;
		std::string saveReparametrizationFileName_;
		bool enableDenseVersion_;
		bool enablePotentialRedistribution_;
		bool saveProblemMasks_;
		std::string maskFileNamePre_;
		size_t threads_;

		LPParameterType lpsolverParameter_;
		ILPParameterType ilpsolverParameter_;

#ifdef OPENGM_COMBILP_DEBUG
		void
		print() const
		{
			std::cout << "maxNumberOfILPCycles=" << maxNumberOfILPCycles_ << std::endl;
			std::cout << "verbose" << verbose_ << std::endl;
			std::cout << "loadReparametrizationFileName=" << loadReparametrizationFileName_ << std::endl;
			std::cout << "saveReparametrizationFileName=" << saveReparametrizationFileName_ << std::endl;
			std::cout << "enableDenseVersion=" << enableDenseVersion_ << std::endl;
			std::cout << "enablePotentialRedistribution=" << enablePotentialRedistribution_ << std::endl;
			std::cout << "saveProblemMasks=" << saveProblemMasks_ << std::endl;
			std::cout << "maskFileNamePre=" << maskFileNamePre_ << std::endl;
		}
#endif
	};

	//
	// Methods
	//
	CombiLP(const GraphicalModelType& gm, const Parameter& param);
	std::string name() const{ return "CombiLP"; }
	const GraphicalModelType& graphicalModel() const { return gm_; }

	InferenceTermination infer();
	template<class VISITOR> InferenceTermination infer(VISITOR&);
	InferenceTermination arg(Labeling &out, const size_t = 1) const;
	ValueType bound() const { return bound_; }
	ValueType value() const { return value_; }

private:
	//
	// Methods
	//
	void performLP();
	template<class VISITOR> InferenceTermination performILP(VISITOR&);

	InferenceTermination inferenceOnSubmodels(const ManipulatorType&);
	bool checkOptimality(const ReparametrizedGMType&, const MaskType&, std::vector<IndexType>&);
	void addNodes(const ReparametrizedGMType&, const std::vector<IndexType>&);

	ValueType debugCalculateNewPrimalBound(const ReparametrizedGMType &) const;
	void debugSaveTreeAgreementLabeling(const Labeling&) const;
	void debugSaveProblemMasks(size_t, const MaskType&) const;
	void debugSaveProblemMasksMismatches(size_t, const std::vector<IndexType>&) const;

	//
	// Members
	//
	Parameter parameter_;
	const GraphicalModelType &gm_;

	// Labeling obtained from the LP relaxation (strictly arc consistent
	// when mask[var] == false).
	std::vector<LabelType> labeling_lp_;

	// This labeling is iteratively adjusted and it will contain the final
	// globally optimal labeling. It starts as the labeling from the tree
	// agreement parts (locally optimal label in the "outer part").
	std::vector<LabelType> labeling_current_;

	ValueType value_;
	ValueType bound_;
	MaskType mask_;
	LPReparametrisationStorage<GraphicalModelType> trws_repa_;

	// The implementation remembers for each node whether it was part of the
	// ILP subproblem. This information is used to determine, if a subproblem
	// has changed between successive iterations. If the subproblem has not
	// changed, inference can be skipped.
	std::vector<bool> ilp_flags_;
};

template<class GM, class ACC, class LP, class ILP>
CombiLP<GM, ACC, LP, ILP>::CombiLP
(
	const GraphicalModelType& gm,
	const Parameter& param
)
: parameter_(param)
, gm_(gm)
, labeling_lp_(gm.numberOfVariables(), 0)
, labeling_current_(gm.numberOfVariables(), 0)
, value_(ACC::template neutral<ValueType>())
, bound_(ACC::template ineutral<ValueType>())
, trws_repa_(gm)
, ilp_flags_(gm.numberOfVariables(), false)
{
#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Parameters of the " << name() << " algorithm:" << std::endl;
	param.print();
#endif
};

template<class GM, class ACC, class LP, class ILP>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::infer()
{
	EmptyVisitorType visitor;
	return infer(visitor);
};

template<class GM, class ACC, class LP, class ILP>
template<class VISITOR>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::infer
(
	VISITOR &visitor
)
{
	visitor.begin(*this);
	performLP();

	// If all nodes are strict-arc-consistent then we already have calculated
	// the globally optimal solution.
	if ( (visitor(*this) != visitors::VisitorReturnFlag::ContinueInf) ||
	     (std::count(mask_.begin(), mask_.end(), true) == 0) )
	{
		visitor.end(*this);
		return NORMAL;
	}

	InferenceTermination result = performILP(visitor);
	visitor.end(*this);

	return result;
}

template<class GM, class ACC, class LP, class ILP>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::arg
(
	Labeling& labeling,
	const size_t idx
) const
{
	if (idx != 1)
		return UNKNOWN;

	labeling = labeling_current_;

	// FIXME: Return the correct inference result.
	return NORMAL;
}

template<class GM, class ACC, class LP, class ILP>
void
CombiLP<GM, ACC, LP, ILP>::performLP()
{
	LPSolverType solver(gm_, parameter_.lpsolverParameter_);

#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Running LP solver "<< solver.name() << std::endl;
#endif

#ifdef WITH_HDF5
	if (parameter_.loadReparametrizationFileName_.compare("") != 0) {
#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "Loading reparametrization..." << std::endl;
#endif
		opengm::hdf5::load(trws_repa_, parameter_.loadReparametrizationFileName_, "gm");
		solver.setReparametrization(trws_repa_);
	}
#endif

	solver.infer();
	value_ = solver.value();
	bound_ = solver.bound();
	solver.getReparametrization(trws_repa_);
	combilp::checkCorruptionInRepa(trws_repa_);

#ifdef WITH_HDF5
	if (parameter_.saveReparametrizationFileName_.compare("") != 0) {
#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "Saving reparametrization..." << std::endl;
#endif
		opengm::hdf5::save(trws_repa_, parameter_.saveReparametrizationFileName_, "gm");
	}
#endif

	combilp::pairwiseReparametrization<AccumulationType>(trws_repa_);
	combilp::computeStrictArcConsistency<AccumulationType>(trws_repa_, labeling_lp_, mask_);

	solver.arg(labeling_current_);
	debugSaveTreeAgreementLabeling(labeling_lp_);

	// Negate the mask. All non-strict-arc-consistent nodes are now “true”.
	OPENGM_ASSERT_OP(mask_.size(), ==, gm_.numberOfVariables());
	std::transform(mask_.begin(), mask_.end(), mask_.begin(), std::logical_not<bool>());

	// Fix the labeling in the strictly arc-consistent areas, as  makes code
	// easier (“dense” can work completely with this labeling).
	for (IndexType i = 0; i < gm_.numberOfVariables(); ++i)
		if (!mask_[i])
			labeling_current_[i] = labeling_lp_[i];

#ifdef OPENGM_COMBILP_DEBUG
	{
		size_t mask_size = std::count(mask_.begin(),mask_.end(),true);
		size_t total = gm_.numberOfVariables();
		double percentage = 100.0 * mask_size / total;
		std::cout << "Energy of the labeling consistent with the arc consistency =" << gm_.evaluate(labeling_current_) << std::endl;
		std::cout << "Arc inconsistent set size = " << mask_size << " / " << total << " (" << percentage << "%)" <<std::endl;
		combilp::checkStrictArcConsistency<ACC>(trws_repa_, labeling_current_, mask_);
	}
#endif
}

// TODO: Clean this method.
template<class GM, class ACC, class LP, class ILP>
template<class VISITOR>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::performILP
(
	VISITOR &visitor
)
{
#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Switching to ILP." << std::endl
	          << (parameter_.enableDenseVersion_
	             ? "The dense version of the CombiLP algorithm is enabled."
	             : "The standard version of the CombiLP algorithm is enabled.")
	          << std::endl;
#endif

	// Do not need to dilate the mask in the newer approach.
	// TODO: Throw away non-dense version?
	if (!parameter_.enableDenseVersion_)
		combilp::dilateMask(gm_, mask_);

	typename ReparametrizerType::ReparametrizedGMType gm;
	bool quitInference = false;
	InferenceTermination result = TIMEOUT;

	// Main loop for iteration. In each iteration we run the ILP solver on the
	// different subproblems. If the labeling has mismatches compared to the
	// strict-arc-consistent labeling (on the “border”) we grow the ILP
	// subproblem.
	//
	// These steps are repeated as long as the iterationen counter is below the
	// user supplied maximum value and there were any mismatches. If there were
	// no mismatches in the previous iteration we are done and we can just
	// concatenate all the labelings.
	for ( size_t iteration = 0
	    ; !quitInference && iteration < parameter_.maxNumberOfILPCycles_
		; ++iteration )
	{
		// The visitor can tell us to stop. He can also see the gap
		// between value_ (always decreasing) and bound (always increasing). He
		// can either raise a timeout or say that the gap is small enough.
		switch (visitor(*this)) {
		case visitors::VisitorReturnFlag::StopInfBoundReached:
			return CONVERGENCE;
			break;
		case visitors::VisitorReturnFlag::StopInfTimeout:
			// TODO: Should we update intermediate values before quitting?
			return TIMEOUT;
			break;
		default:
			break;
		}

#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "ILP iteration " << iteration << " (size = "
		          << std::count(mask_.begin(), mask_.end(), true)
		          << ")" << std::endl;
#endif

		//
		// Calculates boundary mask.
		//
		MaskType boundaryMask(mask_.size());
		combilp::computeBoundaryMask(gm_, mask_, boundaryMask);
		debugSaveProblemMasks(iteration, boundaryMask);

		//
		// Performs reparametrization.
		//
		// Only necessary for dense version of CombiLP (potentials get
		// pushed into the ILP subproblem). For the standard version the
		// reparametrization extracted from the LP will be applied.
		//
		LPReparametrisationStorage<GraphicalModelType> tmp_repa = trws_repa_;
		combilp::checkStrictArcConsistency<ACC>(tmp_repa, labeling_current_, mask_);
		if (parameter_.enablePotentialRedistribution_) {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Performing potential redistribution..." << std::endl;
#endif
			combilp::redistribute_potentials<AccumulationType>(tmp_repa, parameter_.enableDenseVersion_, mask_);
			combilp::checkStrictArcConsistency<ACC>(tmp_repa, labeling_current_, mask_);
		}
		if (parameter_.enableDenseVersion_) {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Performing dense reparametrization..." << std::endl;
#endif
			combilp::dense_reparametrization<AccumulationType>(tmp_repa, mask_);
			combilp::checkStrictArcConsistency<ACC>(tmp_repa, labeling_current_, mask_);
		}

		combilp::checkCorruptionInRepa(tmp_repa);
#if 0
		trws_repa_ = tmp_repa; // We could probably get rid of tmp_repa
#endif

		ReparametrizedGMType gm;
		ReparametrizerType reparametrizer(gm_);
		reparametrizer.Reparametrization() = tmp_repa;
		reparametrizer.getReparametrizedModel(gm);

		//
		// Splits original model into subproblems using the current mask.
		// Runs MRF inference on each of the subproblems.
		//
		ManipulatorType manipulator = combilp::maskToManipulator(gm, labeling_current_, mask_, parameter_.enableDenseVersion_);
		InferenceTermination inf = inferenceOnSubmodels(manipulator);
		if ((inf != NORMAL) && (inf != CONVERGENCE)) {
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "ILP solver failed to solve the problem. Best attained results will be saved." << std::endl;
#endif
			return inf;
		}

#ifndef NDEBUG
		if (parameter_.enableDenseVersion_)
			for (IndexType i = 0; i < gm_.numberOfVariables(); ++i)
				if (! mask_[i])
					OPENGM_ASSERT_OP(labeling_current_[i], ==, labeling_lp_[i]);
#endif

		//
		// Checks for optimality and get list of mismatching labels.
		//
		std::vector<IndexType> mismatches;
		if (checkOptimality(gm, boundaryMask, mismatches)) {
			quitInference = true;
			value_ = bound_ = gm_.evaluate(labeling_current_);
			result = NORMAL;
#ifdef OPENGM_COMBILP_DEBUG
			std::cout << "Solved! Optimal energy=" << value() << std::endl;
#endif
		} else {
			OPENGM_ASSERT_OP(mismatches.size(), >, 0);
			debugSaveProblemMasksMismatches(iteration, mismatches);
#ifndef NDEBUG
			size_t old_size = std::count(mask_.begin(), mask_.end(), true);
#endif
			addNodes(gm, mismatches);
#ifndef NDEBUG
			size_t new_size = std::count(mask_.begin(), mask_.end(), true);
			OPENGM_ASSERT_OP(new_size, >, old_size);
#endif
		}

	}

	return result;
}

template<class GM, class ACC, class LP, class ILP>
InferenceTermination
CombiLP<GM, ACC, LP, ILP>::inferenceOnSubmodels
(
	const ManipulatorType &manipulator
)
{
	std::vector<Labeling> labelings(manipulator.numberOfSubmodels());

	for (size_t i = 0; i < manipulator.numberOfSubmodels(); ++i) {
		const typename ManipulatorType::MGM &model = manipulator.getModifiedSubModel(i);
#if 0
		combilp::debugGraphicalModel(CanonicalView<typename ManipulatorType::MGM>(model));
#endif

		std::vector<IndexType> subVars(model.numberOfVariables());
		std::vector<LabelType> labeling(model.numberOfVariables());
		manipulator.originalSubVariableIndices(i, subVars.begin(), subVars.end());

		bool should_skip = true;
		for (IndexType var = 0; var < model.numberOfVariables(); ++var) {
			labeling[var] = labeling_current_[subVars[var]];
			if (!ilp_flags_[subVars[var]])
				should_skip = false;
			ilp_flags_[subVars[var]] = true;
		}

		if (should_skip) {
		} else {
			ILPSolverType ilpSolver(model, parameter_.ilpsolverParameter_);
			ilpSolver.setStartingPoint(labeling.begin());
			InferenceTermination result = ilpSolver.infer();
			if (result != NORMAL && result != CONVERGENCE)
				return result;

			if (std::abs(ilpSolver.value() - ilpSolver.bound()) > 1e-5) {
				std::cout << "ERROR: VALUE-BOUND MISMATCH" << std::endl;
				return INFERENCE_ERROR;
			}

			ilpSolver.arg(labeling);
		}

		labelings[i] = labeling;
	}

	manipulator.modifiedSubStates2OriginalState(labelings, labeling_current_);
	return NORMAL;
}

template<class GM, class ACC, class LP, class ILP>
bool
CombiLP<GM, ACC, LP, ILP>::checkOptimality
(
	const ReparametrizedGMType &gm,
	const MaskType &boundaryMask,
	std::vector<IndexType> &mismatches
)
{
#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Boundary size=" << std::count(boundaryMask.begin(),boundaryMask.end(),true) << std::endl;
#endif

	bool isOptimal = false;
	ValueType gap = 0, boundaryBound = 0;

	//
	// Checks if there are labeling mismatches on border.
	//
	if (parameter_.enableDenseVersion_) {
		isOptimal = combilp::mismatchingLabelsDense<ACC>(gm, labeling_current_, mask_, mismatches, gap, boundaryBound);
	} else {
		isOptimal = combilp::mismatchingLabels<GM>(labeling_lp_, labeling_current_, boundaryMask, mismatches);
	}

	//
	// Adjust bound. For dense version of CombiLP only.
	//
	if (parameter_.enableDenseVersion_) {
		std::vector<bool> imask = mask_;
		std::transform(imask.begin(), imask.end(), imask.begin(), std::logical_not<bool>());

		ValueType newValue = gm.evaluate(labeling_current_);
		ValueType newBound = gm.evaluate(labeling_current_, mask_)
		                   + gm.evaluate(labeling_current_, imask)
		                   + boundaryBound;

		if (ACC::bop(newValue, value_)) {
			value_ = newValue;

			// TODO: Only keep labeling_current_ if the value has improved,
			// otherwise just use the previous one (basically labeling_current_
			// before the current iteration modified it).
		}

		// for ACC == Minimizer equivalent to: bound_ -= std::min(bound_, newBound)
		ACC::iop(bound_, newBound, bound_);

#ifdef OPENGM_COMBILP_DEBUG
		std::cout << "newvalue=" << newValue << "; best value=" << value_ << std::endl;
		std::cout << "newbound=" << newBound << "; best bound=" << bound_ << std::endl;
		std::cout << "new gap=" << gap << std::endl;
#endif

#ifdef OPENGM_COMBILP_DEBUG_REALY_REALY_HARD
		ValueType newValue2 = debugCalculateNewPrimalBound(gm);
		std::cout << "old primal bound = " << newValue << std::endl;
		std::cout << "new primal bound = " << newValue2 << std::endl;
		std::cout << "ATTENTION " << (newValue2 - newValue) << std::endl;
#endif
	}

	// Either no mismatches, or value equals bound.
	return isOptimal || (std::abs(value_ - bound_) <= std::numeric_limits<ValueType>::epsilon() * value_);
}

template<class GM, class ACC, class LP, class ILP>
void
CombiLP<GM, ACC, LP, ILP>::addNodes
(
	const ReparametrizedGMType &gm,
	const std::vector<IndexType> &mismatches
)
{
#ifdef OPENGM_COMBILP_DEBUG
	std::cout << "Adding " << mismatches.size() << " nodes." << std::endl;
#endif
	typedef typename std::vector<IndexType>::const_iterator Iterator;

	// Expand the mask. For the non-dense version we need to add all
	// neighbooring node.
	//
	// For the dense version we just need to flag the specific node.
	for (Iterator it = mismatches.begin(); it != mismatches.end(); ++it) {
		if (parameter_.enableDenseVersion_)
			mask_[*it]=true;
		else
			combilp::dilateMask(gm, *it, mask_);
	}

}

template<class GM, class ACC, class LP, class ILP>
typename CombiLP<GM, ACC, LP, ILP>::ValueType
CombiLP<GM, ACC, LP, ILP>::debugCalculateNewPrimalBound
(
	const ReparametrizedGMType &gm
) const
{
	MaskType dilated = mask_;
	combilp::dilateMask(gm_, dilated);

	//
	// First GraphicalModelManipulator. Cut out the surrounding part of the
	// problem and leave the red part + boundary of blue part.
	//

	ManipulatorType manipulator(gm, ManipulatorType::DROP);
	for (IndexType i = 0, j = 0; i < gm_.numberOfVariables(); ++i) {
		if (!dilated[i]) {
			manipulator.fixVariable(i, labeling_current_[i]);
		}
	}
	manipulator.lock();
	manipulator.buildModifiedModel();
	const typename ManipulatorType::MGM &mgm = manipulator.getModifiedModel();

	// Second GraphicalModelManipulator. Fix the labels on the remaining
	// blue part.

	typedef GraphicalModelManipulator<typename ManipulatorType::MGM> ManipulatorType2;
	ManipulatorType2 manipulator2(mgm, ManipulatorType2::FIX);
	for (IndexType i = 0; i < gm_.numberOfVariables(); ++i) {
		if (!mask_[i] && dilated[i]) {
			IndexType mapped_i = manipulator.varMap_[i];
			manipulator2.fixVariable(mapped_i, labeling_current_[i]);
		}
	}
	manipulator2.lock();
	manipulator2.buildModifiedModel();
	const typename ManipulatorType2::MGM &mgm2 = manipulator2.getModifiedModel();

	typedef LPCplex<typename ManipulatorType2::MGM, ACC> InferenceType;
	typename InferenceType::Parameter param;
	param.integerConstraint_ = true;
	InferenceType inf(mgm2, param);
	inf.infer();

	Labeling labeling, labelingTmp1, labelingTmp2;
	inf.arg(labelingTmp2);
	manipulator2.modifiedState2OriginalState(labelingTmp2, labelingTmp1);
	manipulator.modifiedState2OriginalState(labelingTmp1, labeling);

	ValueType result = gm_.evaluate(labeling.begin());

	return result;
}

template<class GM, class ACC, class LP, class ILP>
void
CombiLP<GM, ACC, LP, ILP>::debugSaveTreeAgreementLabeling
(
	const Labeling &labeling
) const
{
#if defined(OPENGM_COMBILP_DEBUG)
	if (parameter_.saveProblemMasks_) {
		std::stringstream s;
		s << parameter_.maskFileNamePre_ << "-treeAgreementLabeling.txt";
		combilp::saveContainer(s.str(), labeling.begin(), labeling.end());
	}
#endif
}

template<class GM, class ACC, class LP, class ILP>
void
CombiLP<GM, ACC, LP, ILP>::debugSaveProblemMasks
(
	size_t iteration,
	const MaskType &boundaryMask
) const
{
#if defined(OPENGM_COMBILP_DEBUG)
	if (parameter_.saveProblemMasks_) {
		std::stringstream s;
		s << parameter_.maskFileNamePre_ << "-mask-"
		  << std::setw(4) << std::setfill('0') << iteration
		  << ".txt";
		combilp::saveContainer(s.str(), mask_.begin(), mask_.end());

		s.str(std::string());
		s << parameter_.maskFileNamePre_ << "-boundaryMask-"
		  << std::setw(4) << std::setfill('0') << iteration
		  << ".txt";
		combilp::saveContainer(s.str(), boundaryMask.begin(), boundaryMask.end());
	}
#endif
}

template<class GM, class ACC, class LP, class ILP>
void
CombiLP<GM, ACC, LP, ILP>::debugSaveProblemMasksMismatches
(
	size_t iteration,
	const std::vector<IndexType> &mismatches
) const
{
#if defined(OPENGM_COMBILP_DEBUG)
	if (parameter_.saveProblemMasks_) {
		std::stringstream s;
		s << parameter_.maskFileNamePre_ << "-added-"
		  << std::setw(4) << std::setfill('0') << iteration
		  << ".txt";
		combilp::saveContainer(s.str(), mismatches.begin(), mismatches.end());
	}
#endif
}

} // namespace opengm

#endif
